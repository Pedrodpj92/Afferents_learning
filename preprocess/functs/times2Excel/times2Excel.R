## ---------------------------
##
## File name: times2Excel.R
##
## Purpose of file: read csv with neuron times and trigger (afferent), and transform in coincidence times (correlations) lists to write in excel
##
## Author: Pedro Del Pozo Jim√©nez
##
## Date Created: 2020-01-29
##
## Email: pedrodpj92@gmail.com
##
## This file is part of Afferents_learning.
## 
## Afferents_learning is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## Afferents_learning is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <https://www.gnu.org/licenses/>.
##
## ---------------------------
##
## Notes:
##
##
## ---------------------------





times2Excel <- function(path_neurons, path_afferents,
                        index_choosen_afferent = 1,
                        output_pos = "./output_pos.xlsx", output_neg = "./output_neg.xlsx",
                        na_strings = "NaN"){ #by default, NaN is used in MATLAB, where our csv are produced when .mat is generated by Spike2, recording software that we use
  
  source("./preprocess/functs/times2Excel/vec2Correlated.R")
  source("./preprocess/functs/times2Excel/save_Excel.R")
  
  ##load data
  dt_input_neurons <- read.csv(file = path_neurons, na.strings = na_strings)
  dt_trigger <- read.csv(file = path_afferents, na.strings = na_strings)
  
  neu_t_list <- lapply(dt_input_neurons, as.vector)
  neu_t_list <- lapply(neu_t_list,na.exclude)
  
  #trigger == afferent
  trig_t <- dt_trigger[,index_choosen_afferent]
  trig_t <- c(na.exclude(trig_t))
  
  ##positive intervals
  cat(paste0("> correlations with afferent (positive cases)...","\n"))
  dt_pos_times <- vec2Correlated(neurons_times_list = neu_t_list,
                                 trigger_times = trig_t)

  #afferent is included into neurons set
  neu_t_list2 <- neu_t_list
  neu_t_list2[[length(neu_t_list)+1]] <- trig_t
  names(neu_t_list2)[length(neu_t_list2)] <- "R" #in future, when names matter, this can be choosen by parameter or config
  
  ##trigger == sampling along the experiment, 0.05 each "step", 20Hz? Choose your intervals
  #calculate the maximun with a little margin of 5 seconds
  time_max_sampling <- max(unlist(neu_t_list2))+5.00 
  trig_t2 <- seq(from=0,to=time_max_sampling,by=0.05) 
  cat(paste0("max duration neurons: ",max(unlist(neu_t_list)),"\n"))
  cat(paste0("max duration afferent: ",max(unlist(trig_t)),"\n"))
  cat(paste0("max duration sampling: ",time_max_sampling,"\n"))
  
  post_vec<- rep(0.00,length(neu_t_list))
  post_vec <- c(post_vec,0.05)#special case for afferent, look for at its right too
  
  cat(paste0("> correlations with sampling (negative cases)...","\n"))
  ##negative intervals
  dt_neg_times <- vec2Correlated(neurons_times_list = neu_t_list2,
                                 trigger_times = trig_t2,
                                 post_margin_vector = post_vec)
  
  #Saving data
  save_Excel(list_input = dt_pos_times, path_output = output_pos)
  save_Excel(list_input = dt_neg_times, path_output = output_neg)
  
  
  return(list(pos=dt_pos_times,neg=dt_neg_times,time_max=time_max_sampling))
}


